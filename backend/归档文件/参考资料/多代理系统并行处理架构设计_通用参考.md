# 多代理系统并行处理架构设计 - 通用参考文档

**文档版本**: 1.0
**创建日期**: 2025-10-26
**适用场景**: 多阶段、多代理协作的批量处理系统
**来源项目**: 债权审查三代理协作系统
**验证状态**: ✅ 已在生产环境验证（效率提升60-78%）

---

## 📋 文档概述

本文档总结了一套经过验证的**多代理系统并行处理架构设计**，该设计可以应用于任何符合以下特征的系统：

✅ **多阶段处理流程**（Stage 1 → Stage 2 → Stage 3 → ...）
✅ **每个阶段有明确的输入输出**
✅ **需要处理多个独立的数据实体**（如多个客户、多个案件、多个订单）
✅ **使用代理（Agent）完成各阶段任务**
✅ **对数据隔离和质量有严格要求**

**核心价值**：在保持串行处理的质量标准下，通过**阶段内并行**实现 60-80% 的效率提升。

---

## 🎯 核心设计原则

### 原则 1: 阶段内并行 vs 跨阶段串行

```
✅ 允许：同一阶段处理多个不同实体（Stage-Level Parallelism）
  Example: 5个客户同时进行阶段1处理

❌ 禁止：同一实体的多个阶段同时进行（Cross-Stage Parallelism）
  Example: 客户A的阶段1、阶段2、阶段3同时进行

理由：阶段之间有数据依赖关系，必须顺序执行
```

**工作流示例**：
```
正确的并行模式（Serial Stages, Parallel Entities）:
┌─────────────────────────────────────────────┐
│ Stage 1 (Parallel)                          │
│ ├─ Entity A ─┐                              │
│ ├─ Entity B ─┼─ 同时执行                    │
│ ├─ Entity C ─┤                              │
│ └─ Entity D ─┘                              │
└─────────────────────────────────────────────┘
              ↓ (全部完成后)
┌─────────────────────────────────────────────┐
│ Stage 2 (Parallel)                          │
│ ├─ Entity A ─┐                              │
│ ├─ Entity B ─┼─ 同时执行                    │
│ ├─ Entity C ─┤                              │
│ └─ Entity D ─┘                              │
└─────────────────────────────────────────────┘

错误的并行模式（Parallel Stages, Serial Entities）:
Entity A: Stage 1 ─┐
Entity A: Stage 2 ─┼─ ❌ 同时执行（数据依赖冲突）
Entity A: Stage 3 ─┘
```

### 原则 2: 完全自包含的任务指令（Self-Contained Prompts）

**定义**：每个并行 Agent 的 prompt 必须包含该实体的**所有必要信息**，不依赖任何全局状态或隐式上下文。

**必须包含的元素**：
1. **实体身份标识**（三重标识：批次、编号、名称）
2. **配置文件路径**（绝对路径）
3. **输入材料路径**（绝对路径）
4. **前置阶段输出路径**（阶段2、3需要，绝对路径）
5. **输出目录路径**（绝对路径）
6. **关键参数**（日期、金额等业务参数）
7. **任务指令**（详细的工作要求）
8. **验证检查清单**（防污染措施）

**反模式**（避免）：
- ❌ "处理当前客户" - 没有明确指定是哪个客户
- ❌ "读取配置文件" - 没有指定具体路径
- ❌ "使用上一阶段的结果" - 没有指定具体文件路径
- ❌ 依赖全局变量或共享状态

### 原则 3: 三层验证机制（Zero Context Pollution）

**目标**：确保不同实体的处理完全隔离，零交叉污染。

**三层验证**：

```
Layer 1 - 启动验证（Agent Start）
┌────────────────────────────────────────┐
│ 读取配置文件                            │
│ 验证: config.entity_id == prompt.entity_id │
│ 如不一致 → STOP 并报错                  │
└────────────────────────────────────────┘

Layer 2 - 文件操作验证（File Operations）
┌────────────────────────────────────────┐
│ 读取输入文件前                          │
│ 验证: file_path contains entity_id     │
│ 写入输出文件前                          │
│ 验证: output_path contains entity_id   │
└────────────────────────────────────────┘

Layer 3 - 完成验证（Completion Check）
┌────────────────────────────────────────┐
│ 报告完成前                              │
│ 验证: report.entity_id == prompt.entity_id │
│ 验证: 仅处理了prompt指定的实体          │
└────────────────────────────────────────┘
```

### 原则 4: 质量一致性保证

**核心要求**：并行处理的质量标准必须与串行处理完全相同。

**实现方式**：
- ✅ 使用相同的 Agent 定义
- ✅ 使用相同的 Skill 知识库
- ✅ 应用相同的验证规则
- ✅ 执行相同的质量检查
- ✅ 唯一差异：执行方式（串行 vs 并行）

**验收标准**：
```
并行处理结果 == 串行处理结果
（逐文件、逐字段对比）
```

---

## 🏗️ 系统架构设计

### 整体架构图

```
┌─────────────────────────────────────────────────────────┐
│                  批量处理系统架构                          │
└─────────────────────────────────────────────────────────┘

                    ┌──────────────┐
                    │  用户输入     │
                    │ (批量实体)    │
                    └──────┬───────┘
                           │
              ┌────────────┴────────────┐
              │                         │
        ┌─────▼─────┐           ┌──────▼──────┐
        │ 串行模式   │           │ 并行模式     │
        │ (Mode 1)  │           │ (Mode 2)    │
        └─────┬─────┘           └──────┬──────┘
              │                        │
              │         ┌──────────────┴──────────────┐
              │         │                             │
              │    ┌────▼─────┐                 ┌────▼─────┐
              │    │ 环境初始化│                 │Prompt生成 │
              │    │ (串行)    │                 │ (自动)    │
              │    └────┬─────┘                 └────┬──────┘
              │         │                             │
              │         └──────────────┬──────────────┘
              │                        │
              ▼                        ▼
        ┌──────────────────────────────────────────┐
        │          阶段1: 并行/串行执行              │
        │  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐ │
        │  │Agent1│  │Agent2│  │Agent3│  │Agent4│ │
        │  │实体A │  │实体B │  │实体C │  │实体D │ │
        │  └──┬───┘  └──┬───┘  └──┬───┘  └──┬───┘ │
        └─────┼─────────┼─────────┼─────────┼─────┘
              │         │         │         │
              └─────────┴─────────┴─────────┘
                        │
                 ┌──────▼──────┐
                 │质量检查点1   │
                 │(Checkpoint 1)│
                 └──────┬──────┘
                        │
        ┌───────────────▼────────────────────────┐
        │          阶段2: 并行/串行执行            │
        │               (同上)                   │
        └───────────────┬────────────────────────┘
                        │
                 ┌──────▼──────┐
                 │质量检查点2   │
                 └──────┬──────┘
                        │
                      (...)
                        │
                 ┌──────▼──────┐
                 │  最终验收    │
                 └──────┬──────┘
                        │
                    ┌───▼────┐
                    │交付结果 │
                    └────────┘
```

### 目录结构设计

**标准目录结构**（每个实体一个）：

```
输出/第X批/[编号]-[实体名称]/
├── .processing_config.json          # 实体配置（关键）
├── 阶段1输出/                        # Stage 1 outputs
│   └── [实体]_阶段1报告.md
├── 阶段2输出/                        # Stage 2 outputs
│   └── [实体]_阶段2报告.md
├── 阶段3输出/                        # Stage 3 outputs
│   └── [实体]_阶段3报告.md
├── 计算文件/                         # Calculation files (if needed)
│   └── [实体]_计算.xlsx
└── 并行处理prompts/                  # Parallel prompts (audit trail)
    ├── stage1_[实体]_prompt.txt
    ├── stage2_[实体]_prompt.txt
    └── stage3_[实体]_prompt.txt
```

**配置文件结构**（.processing_config.json）：

```json
{
  "entity_info": {
    "batch_number": "1",
    "entity_id": "12345",
    "entity_name": "客户A",
    "processing_date": "20251026"
  },
  "paths": {
    "base_directory": "/path/to/output/batch1/12345-客户A",
    "stage1_output": "/path/to/.../阶段1输出",
    "stage2_output": "/path/to/.../阶段2输出",
    "stage3_output": "/path/to/.../阶段3输出",
    "calculation_files": "/path/to/.../计算文件",
    "parallel_prompts": "/path/to/.../并行处理prompts"
  },
  "file_templates": {
    "stage1_report": "[实体名称]_阶段1报告.md",
    "stage2_report": "[实体名称]_阶段2报告.md",
    "stage3_report": "[实体名称]_阶段3报告.md"
  },
  "business_params": {
    "key_date": "2023-05-12",
    "amount": "100000.00",
    "status": "active"
  }
}
```

---

## 🔧 技术实现指南

### 1. 环境初始化（必须，串行）

**目的**：为每个实体创建标准目录结构和配置文件。

**实现方式**：工作流控制器脚本

```python
# 工作流控制器伪代码
class WorkflowController:
    def initialize_entity(self, batch, entity_id, entity_name):
        """为单个实体初始化环境"""
        # 1. 创建基础目录
        base_dir = f"输出/第{batch}批/{entity_id}-{entity_name}"
        create_directories(base_dir, [
            "阶段1输出",
            "阶段2输出",
            "阶段3输出",
            "计算文件",
            "并行处理prompts"
        ])

        # 2. 生成配置文件
        config = {
            "entity_info": {
                "batch_number": batch,
                "entity_id": entity_id,
                "entity_name": entity_name,
                "processing_date": today()
            },
            "paths": {
                "base_directory": base_dir,
                "stage1_output": f"{base_dir}/阶段1输出",
                "stage2_output": f"{base_dir}/阶段2输出",
                "stage3_output": f"{base_dir}/阶段3输出",
                "calculation_files": f"{base_dir}/计算文件",
                "parallel_prompts": f"{base_dir}/并行处理prompts"
            },
            "file_templates": {
                "stage1_report": f"{entity_name}_阶段1报告.md",
                # ...
            },
            "business_params": load_business_params()
        }

        save_json(f"{base_dir}/.processing_config.json", config)

        # 3. 验证
        validate_directory_structure(base_dir)

        return config

# 批量初始化（串行执行）
for entity in entity_list:
    controller.initialize_entity(batch, entity.id, entity.name)
```

**关键点**：
- ✅ 必须在并行处理前完成
- ✅ 串行执行（避免并发写入冲突）
- ✅ 验证所有配置文件创建成功
- ✅ 标准化的目录结构

### 2. Prompt 生成（自动化）

**目的**：为每个实体自动生成自包含的任务指令。

**实现方式**：Prompt 生成器脚本

```python
# Prompt生成器伪代码
class PromptGenerator:
    def generate_stage_prompt(self, stage, batch, entity_id, entity_name):
        """生成某个阶段的prompt"""
        # 1. 加载配置
        config = load_config(f"输出/第{batch}批/{entity_id}-{entity_name}/.processing_config.json")

        # 2. 加载模板
        template = load_template(f"templates/stage{stage}_template.md")

        # 3. 填充模板
        prompt = template.format(
            # 实体标识
            batch_number=batch,
            entity_id=entity_id,
            entity_name=entity_name,
            processing_date=config['entity_info']['processing_date'],

            # 路径信息（绝对路径）
            config_file_path=f"{config['paths']['base_directory']}/.processing_config.json",
            input_file_path=f"输入/第{batch}批/{entity_id}.{entity_name}.md",
            output_dir=config['paths'][f'stage{stage}_output'],

            # 前置阶段输出（如果需要）
            prev_stage_output=self._get_prev_stage_output(stage, config) if stage > 1 else None,

            # 业务参数
            business_params=config['business_params'],

            # 验证清单
            verification_checklist=self._generate_checklist(entity_id, entity_name)
        )

        # 4. 保存prompt
        prompt_file = f"{config['paths']['parallel_prompts']}/stage{stage}_{entity_id}_{entity_name}_prompt.txt"
        save_file(prompt_file, prompt)

        return prompt

    def generate_batch_prompts(self, stage, batch, entity_list):
        """批量生成prompts"""
        prompts = {}
        for entity in entity_list:
            prompt = self.generate_stage_prompt(stage, batch, entity.id, entity.name)
            prompts[entity.id] = prompt
        return prompts

# 使用示例
generator = PromptGenerator()
prompts = generator.generate_batch_prompts(stage=1, batch=1, entity_list=[
    Entity(id="001", name="客户A"),
    Entity(id="002", name="客户B"),
    Entity(id="003", name="客户C")
])
```

**Prompt 模板标准结构**：

```markdown
# [实体名称] - 阶段[X]并行处理任务

## ⚠️ 重要说明：并行处理模式
你正在**并行处理模式**下工作。本次任务**仅处理实体 [实体名称]**。

**关键要求**:
- 所有信息都在本 prompt 中提供，不要依赖外部上下文
- 使用绝对路径，不要猜测路径
- 严格执行三重验证机制
- 仅处理本 prompt 中明确指定的实体

---

## 第一部分：实体身份标识

**批次号**: [X]
**实体编号**: [XXX]
**实体名称**: [完整名称]
**处理日期**: [YYYYMMDD]

**身份验证要求**:
- 在开始工作前，读取配置文件验证上述信息
- 如配置文件中的信息与上述不一致，立即停止并报告错误
- 在报告中明确记录实体身份

---

## 第二部分：配置文件路径

**配置文件路径（绝对路径，必须使用）**:
```
[绝对路径]/.processing_config.json
```

**使用要求**:
1. 必须读取此配置文件获取路径和文件名模板
2. 读取后验证 entity_info 与第一部分的标识一致
3. 使用配置中的 paths 进行所有文件操作

---

## 第三部分：输入材料路径

**材料文件路径（绝对路径）**:
```
[绝对路径]/输入材料.md
```

**读取要求**:
1. 必须读取此路径的材料文件
2. 读取前验证路径包含正确的实体标识
3. 读取后验证文件内容对应正确的实体

---

## 第四部分：前置阶段输出路径（阶段2+需要）

**前置阶段报告路径（绝对路径）**:
```
[绝对路径]/阶段[X-1]报告.md
```

**读取要求（防污染关键）**:
1. 必须读取此报告作为依据
2. 读取后验证报告中的实体信息与本 prompt 一致
3. 如验证失败，立即停止并报告错误

---

## 第五部分：输出目录路径

**输出目录（绝对路径）**:
```
[绝对路径]/阶段[X]输出/
```

**输出文件名**:
```
[实体名称]_阶段[X]报告.md
```

**输出要求**:
1. 报告必须保存到上述目录
2. 文件名使用配置文件中的模板
3. 写入前验证目录路径包含正确实体标识
4. 写入后验证文件已成功保存

---

## 第六部分：关键参数

**[业务参数1]**: [值]
**[业务参数2]**: [值]
**[业务参数3]**: [值]

**参数验证要求**:
1. 与配置文件中的参数交叉验证
2. 如发现不一致，立即停止并报告错误
3. 在输出报告中明确记录这些参数

---

## 第七部分：任务指令

请按照 [agent-name] 的标准工作流程执行 [任务描述]。

**完整任务要求**: 参考 [agent定义文件] 和 [skill文件]。

---

## 第八部分：防污染检查清单

### 启动前验证
- [ ] 读取配置文件并验证实体信息一致
- [ ] 输入材料路径包含正确的实体标识
- [ ] 前置报告（如有）实体信息一致

### 完成后自我验证
- [ ] 报告中的实体名称 == "[实体名称]"
- [ ] 报告中的实体编号 == "[编号]"
- [ ] 报告内容对应该实体的输入材料
- [ ] 文件已保存到正确的目录
- [ ] 仅处理了 prompt 指定的实体 [实体名称]

如以上任何一项不满足，请立即停止并报告问题。

---

**实体**: [实体名称]（编号 [XXX]）
**阶段**: [X] - [阶段名称]
**模式**: 并行处理
```

### 3. 并行执行

**实现方式**：在一个消息中发起多个 Task 调用

```
用户消息示例：

我要并行处理第1批的3个实体的阶段1任务。请使用3个独立的 agent 实例。

[然后在同一消息中调用3次 Task 工具]

Task 1:
  subagent_type: stage1-agent
  description: Process entity 001
  prompt: [实体001的完整自包含prompt]

Task 2:
  subagent_type: stage1-agent
  description: Process entity 002
  prompt: [实体002的完整自包含prompt]

Task 3:
  subagent_type: stage1-agent
  description: Process entity 003
  prompt: [实体003的完整自包含prompt]
```

**关键点**：
- ✅ 所有 Task 在**同一个消息**中发起（确保并行）
- ✅ 每个 Task 使用**完整的自包含 prompt**
- ✅ 等待所有 Task 完成后再进行质量检查

### 4. 质量检查点

**在每个阶段完成后执行**：

```python
# 质量检查伪代码
class QualityChecker:
    def checkpoint(self, stage, batch, entity_list):
        """阶段质量检查"""
        results = {
            "passed": [],
            "failed": [],
            "warnings": []
        }

        for entity in entity_list:
            # 1. 文件存在性检查
            if not self.check_output_exists(stage, batch, entity):
                results["failed"].append({
                    "entity": entity,
                    "reason": "输出文件不存在"
                })
                continue

            # 2. 实体标识一致性检查
            if not self.check_entity_identity(stage, batch, entity):
                results["failed"].append({
                    "entity": entity,
                    "reason": "实体标识不一致"
                })
                continue

            # 3. 业务参数一致性检查
            if not self.check_business_params(stage, batch, entity):
                results["warnings"].append({
                    "entity": entity,
                    "reason": "业务参数不一致"
                })

            # 4. 内容独立性检查（防污染）
            if not self.check_content_independence(stage, batch, entity, entity_list):
                results["failed"].append({
                    "entity": entity,
                    "reason": "检测到跨实体污染"
                })
                continue

            # 5. 如果通过所有检查
            results["passed"].append(entity)

        return results

    def check_content_independence(self, stage, batch, entity, all_entities):
        """检查内容独立性（防污染）"""
        output = load_output(stage, batch, entity)

        # 在当前实体的输出中搜索其他实体的名称
        for other_entity in all_entities:
            if other_entity.id == entity.id:
                continue  # 跳过自己

            if other_entity.name in output:
                # 发现交叉引用，可能污染
                return False

        return True
```

**检查清单模板**：

```markdown
## 质量检查点 [X]：阶段[X]完成验证

### 检查项目

#### 1. 文件存在性 ✅/❌
- [ ] 所有实体的阶段[X]输出文件已生成
- [ ] 文件位于正确的目录
- [ ] 文件命名符合模板

命令:
find 输出/第[X]批 -name "*阶段[X]报告.md" | wc -l
# 应该等于实体数量

#### 2. 实体标识一致性 ✅/❌
- [ ] 每个报告中的实体名称正确
- [ ] 每个报告中的实体编号正确
- [ ] 报告中的批次号正确

命令:
grep "实体名称" 输出/第[X]批/001-客户A/阶段[X]输出/*报告.md
# 应该显示: 客户A

#### 3. 业务参数一致性 ✅/❌
- [ ] 关键日期在所有报告中一致
- [ ] 关键金额准确无误
- [ ] 其他业务参数正确

命令:
grep "关键日期" 输出/第[X]批/*/阶段[X]输出/*报告.md
# 所有结果应该一致

#### 4. 内容独立性（防污染）✅/❌
- [ ] 实体A的报告中不包含实体B的名称
- [ ] 实体B的报告中不包含实体C的名称
- [ ] 无跨实体引用

命令:
grep "客户B" 输出/第[X]批/001-客户A/阶段[X]输出/*报告.md
# 应该: 没有结果（证明独立）

#### 5. 前后阶段一致性（阶段2+）✅/❌
- [ ] 阶段[X]报告中的实体信息与阶段[X-1]一致
- [ ] 关键数据在两个阶段间保持一致

### 验收标准

**全部通过 → 进入下一阶段**
**任何失败 → 识别失败实体，单独重新处理**
```

---

## 📦 可复用组件清单

### 1. 工作流控制器脚本

**功能**：环境初始化、配置生成、目录验证

**接口**：
```python
class WorkflowController:
    def initialize_entity(batch, entity_id, entity_name) -> config
    def validate_directory_structure(base_dir) -> bool
    def check_file_placement(config) -> report
```

**适配要点**：
- 修改目录名称（阶段1输出 → 你的阶段名）
- 修改配置字段（entity → 你的实体类型）
- 保持绝对路径和验证机制

### 2. Prompt 生成器脚本

**功能**：自动生成自包含的任务指令

**接口**：
```python
class PromptGenerator:
    def generate_stage_prompt(stage, batch, entity_id, entity_name) -> prompt
    def generate_batch_prompts(stage, batch, entity_list) -> prompts_dict
```

**适配要点**：
- 修改模板路径
- 修改业务参数字段
- 保持 prompt 的8个标准部分结构

### 3. 质量检查器

**功能**：阶段完成验证、污染检测

**接口**：
```python
class QualityChecker:
    def checkpoint(stage, batch, entity_list) -> results
    def check_entity_identity(stage, batch, entity) -> bool
    def check_content_independence(stage, batch, entity, all_entities) -> bool
```

**适配要点**：
- 修改检查规则（根据你的业务）
- 修改污染检测逻辑（搜索关键字）
- 保持检查的系统性和完整性

### 4. 配置文件模板

**文件**：`.processing_config.json`

**结构**：
```json
{
  "entity_info": { /* 实体标识 */ },
  "paths": { /* 绝对路径 */ },
  "file_templates": { /* 文件名模板 */ },
  "business_params": { /* 业务参数 */ }
}
```

**适配要点**：
- 修改字段名称
- 保持绝对路径
- 确保所有必要信息都包含

### 5. Prompt 模板

**文件**：`stage[X]_template.md`

**结构**：8个标准部分（见上文）

**适配要点**：
- 修改业务术语
- 修改任务指令
- 保持验证清单和防污染措施

---

## 🔄 适配到新项目的步骤

### Step 1: 分析项目特征

**回答以下问题**：

1. **有多少个处理阶段？**
   - Example: 3个阶段（数据提取 → 数据分析 → 报告生成）

2. **每个阶段的输入输出是什么？**
   - Stage 1: 输入原始文件 → 输出结构化数据
   - Stage 2: 输入结构化数据 → 输出分析结果
   - Stage 3: 输入分析结果 → 输出最终报告

3. **处理的基本单位是什么？**
   - Example: 客户、订单、案件、项目等

4. **实体的唯一标识是什么？**
   - Example: 客户编号 + 客户名称

5. **关键业务参数有哪些？**
   - Example: 日期、金额、状态等

### Step 2: 设计目录结构

**根据你的阶段设计目录**：

```
输出/第X批/[实体标识]/
├── .processing_config.json
├── [你的阶段1名称]/
├── [你的阶段2名称]/
├── [你的阶段3名称]/
├── [其他必要目录]/
└── 并行处理prompts/
```

### Step 3: 修改配置文件结构

**适配你的业务字段**：

```json
{
  "[你的实体类型]_info": {
    "batch_number": "...",
    "[你的ID字段]": "...",
    "[你的名称字段]": "...",
    "processing_date": "..."
  },
  "paths": {
    "[你的阶段1路径]": "...",
    "[你的阶段2路径]": "...",
    // ...
  },
  "file_templates": {
    "[你的文件1]": "...",
    "[你的文件2]": "...",
    // ...
  },
  "[你的业务参数组]": {
    "[参数1]": "...",
    "[参数2]": "...",
    // ...
  }
}
```

### Step 4: 创建 Prompt 模板

**为每个阶段创建模板**：

1. 复制标准8部分结构
2. 修改：
   - 实体类型术语
   - 阶段名称
   - 业务参数
   - 任务指令
3. 保持：
   - 身份验证机制
   - 绝对路径要求
   - 防污染检查清单

### Step 5: 实现工作流控制器

**基于你的技术栈**：

```python
# Python示例
class YourWorkflowController:
    def __init__(self, project_root):
        self.project_root = Path(project_root)
        self.output_root = self.project_root / "输出"

    def initialize_entity(self, batch, entity_id, entity_name):
        # 1. 创建目录
        # 2. 生成配置
        # 3. 验证
        pass
```

```javascript
// JavaScript示例
class YourWorkflowController {
    constructor(projectRoot) {
        this.projectRoot = projectRoot;
        this.outputRoot = path.join(projectRoot, '输出');
    }

    initializeEntity(batch, entityId, entityName) {
        // 1. 创建目录
        // 2. 生成配置
        // 3. 验证
    }
}
```

### Step 6: 实现 Prompt 生成器

**自动化 prompt 生成**：

```python
class YourPromptGenerator:
    def generate_stage_prompt(self, stage, batch, entity_id, entity_name):
        # 1. 加载配置
        config = self.load_config(batch, entity_id, entity_name)

        # 2. 加载模板
        template = self.load_template(f"stage{stage}_template.md")

        # 3. 填充模板
        prompt = template.format(**self.prepare_variables(config))

        # 4. 保存到实体的并行处理prompts目录
        self.save_prompt(prompt, config['paths']['parallel_prompts'], stage, entity_id, entity_name)

        return prompt
```

### Step 7: 实现质量检查器

**适配你的检查规则**：

```python
class YourQualityChecker:
    def checkpoint(self, stage, batch, entity_list):
        results = {"passed": [], "failed": [], "warnings": []}

        for entity in entity_list:
            # 1. 文件存在性
            # 2. 实体标识一致性
            # 3. 业务参数一致性
            # 4. 内容独立性（防污染）
            # 5. 前后阶段一致性

            if all_checks_passed:
                results["passed"].append(entity)
            else:
                results["failed"].append({"entity": entity, "reason": "..."})

        return results
```

### Step 8: 测试验证

**小规模测试**：

1. **测试1: 串行处理2-3个实体**
   - 验证基本功能正确
   - 建立基准结果

2. **测试2: 并行处理2-3个实体**
   - 验证并行执行正常
   - 对比串行结果，确保一致

3. **测试3: 污染检测**
   - 故意在实体A的输出中引用实体B
   - 验证质量检查能检测出来

4. **测试4: 错误恢复**
   - 模拟实体B处理失败
   - 验证其他实体不受影响
   - 验证可以单独重新处理实体B

### Step 9: 扩大规模

**逐步增加批量大小**：

```
阶段1: 2-3个实体（测试）
阶段2: 5个实体（小批量）
阶段3: 10个实体（中批量）
阶段4: 20+个实体（大批量）
```

**监控指标**：
- 成功率
- 效率提升比例
- 污染检测率
- 错误恢复时间

---

## 📈 性能优化建议

### 1. 批量大小选择

**推荐批量大小**：

| 实体数量 | 推荐策略 | 单批大小 | 预期效率提升 |
|---------|---------|---------|-------------|
| 1-2个 | 串行处理 | N/A | 0% (无需并行) |
| 3-5个 | 单批并行 | 3-5 | 60-70% |
| 6-15个 | 分批并行 | 5-8 | 65-75% |
| 15+个 | 多批并行 | 5-10 | 70-80% |

**理由**：
- 太小：并行overhead抵消收益
- 太大：资源竞争，可能超时
- 最佳：5-8个实体/批

### 2. 资源管理

**并行执行时的资源考虑**：

```
并行度 = min(
    实体数量,
    可用CPU核心数 / 2,
    可用内存 / 单实体内存需求,
    平台并发限制
)
```

**监控指标**：
- CPU使用率（<80%）
- 内存使用率（<85%）
- 网络带宽（如有API调用）
- 磁盘I/O

### 3. 错误隔离

**原则**：一个实体的失败不影响其他实体

**实现**：
```python
try:
    process_entity(entity_A)
except Exception as e:
    log_error(entity_A, e)
    mark_as_failed(entity_A)
    # 继续处理其他实体
```

**恢复策略**：
```
1. 识别失败的实体
2. 分析失败原因
3. 修复问题（数据、配置、代码）
4. 仅重新处理失败的实体
5. 成功的实体保持不变
```

---

## ⚠️ 常见陷阱和解决方案

### 陷阱 1: 共享状态污染

**问题**：不同实体的 Agent 共享全局变量

```python
# ❌ 错误示例
current_entity = None  # 全局变量

def process():
    global current_entity
    # 并行时可能被其他Agent覆盖
    current_entity = "Entity A"
    ...
```

**解决方案**：完全自包含的 prompt

```python
# ✅ 正确示例
def process(entity_id, entity_name, config_path, input_path, ...):
    # 所有信息通过参数传递
    # 不依赖任何全局状态
    ...
```

### 陷阱 2: 相对路径依赖

**问题**：使用相对路径导致文件读取错误

```python
# ❌ 错误示例
config = read_json("./config.json")  # 相对路径
```

**解决方案**：始终使用绝对路径

```python
# ✅ 正确示例
config = read_json("/absolute/path/to/config.json")
```

### 陷阱 3: 隐式上下文假设

**问题**：Agent假设"当前实体"已知

```python
# ❌ 错误示例（prompt）
"处理当前实体的数据..."
```

**解决方案**：明确指定实体

```python
# ✅ 正确示例（prompt）
"处理实体编号为001、名称为'客户A'的数据..."
```

### 陷阱 4: 跳过验证步骤

**问题**：为了速度跳过身份验证

```python
# ❌ 错误示例
def process(prompt):
    # 直接开始处理，不验证
    ...
```

**解决方案**：强制三层验证

```python
# ✅ 正确示例
def process(prompt):
    # Layer 1: 启动验证
    config = load_config(prompt.config_path)
    assert config.entity_id == prompt.entity_id

    # Layer 2: 文件操作验证
    assert prompt.entity_id in input_file_path

    # 处理...

    # Layer 3: 完成验证
    assert output.entity_id == prompt.entity_id
```

### 陷阱 5: 不完整的错误报告

**问题**：错误信息不包含实体标识

```python
# ❌ 错误示例
raise Exception("配置文件不存在")
```

**解决方案**：错误信息包含完整上下文

```python
# ✅ 正确示例
raise Exception(f"实体 {entity_id}-{entity_name} 的配置文件不存在: {config_path}")
```

---

## 🎓 最佳实践总结

### 设计原则

1. **阶段内并行，阶段间串行** ✅
2. **完全自包含的任务指令** ✅
3. **三层验证机制** ✅
4. **质量一致性保证** ✅
5. **错误隔离和恢复** ✅

### 实现要点

1. **环境初始化必须先于并行处理** ✅
2. **使用绝对路径，不用相对路径** ✅
3. **自动化 prompt 生成** ✅
4. **每个阶段后执行质量检查** ✅
5. **保存 prompts 作为审计追踪** ✅

### 质量控制

1. **文件存在性检查** ✅
2. **实体标识一致性检查** ✅
3. **业务参数一致性检查** ✅
4. **内容独立性检查（防污染）** ✅
5. **前后阶段一致性检查** ✅

### 运维建议

1. **小规模测试后再扩大批量** ✅
2. **监控资源使用情况** ✅
3. **保留详细的处理日志** ✅
4. **建立错误恢复机制** ✅
5. **定期审查并行处理效果** ✅

---

## 📊 效果评估

### 评估维度

**效率提升**：
```
效率提升 = (串行耗时 - 并行耗时) / 串行耗时 × 100%
```

**质量一致性**：
```
质量得分 = 并行结果与串行结果的一致性百分比
目标: 100% 一致
```

**污染率**：
```
污染率 = 检测到污染的实体数量 / 总实体数量
目标: 0% 污染
```

**成功率**：
```
成功率 = 首次处理成功的实体数量 / 总实体数量
目标: >95%
```

### 验证测试案例

**来源项目验证结果**（债权审查系统）：

```
测试规模: 3个债权人 × 3个阶段
串行耗时: 60.4分钟
并行耗时: 23.9分钟
效率提升: 60.4%

质量验证:
- 文件完整性: 100% ✅
- 实体标识一致性: 100% ✅
- 业务参数一致性: 100% ✅
- 内容独立性: 100% ✅ (0次交叉引用)
- 前后阶段一致性: 100% ✅

综合评价: 所有测试通过 ✅
```

---

## 🔗 参考资源

### 来源项目文档

如需查看完整的实现细节，参考以下文件：

**核心协议**：
- `PARALLEL_PROCESSING_PROTOCOL.md` - 技术协议和规范

**质量标准**：
- `PARALLEL_QUALITY_CHECKLIST.md` - 质量检查清单

**详细指南**（已归档）：
- `归档文件/并行处理文档_20251026/PARALLEL_PROCESSING_USER_GUIDE.md` - 用户操作手册
- `归档文件/并行处理文档_20251026/PARALLEL_PROCESSING_SOP.md` - 标准操作流程

**测试报告**（已归档）：
- `归档文件/并行处理文档_20251026/PARALLEL_PROCESSING_TEST_REPORT.md` - 完整测试报告

### Skills 架构集成

并行处理设计已完全集成到 Skills 架构：

**Skill 文档**：
- `.claude/skills/debt-workflow-orchestration/SKILL.md` - Part 10: Stage-Level Parallel Processing

### 代码实现

**工作流控制器**：
- `债权处理工作流控制器.py` - 环境初始化实现

**Prompt 生成器**：
- `parallel_prompt_generator.py` - 自动化 prompt 生成

---

## 📝 许可和使用

**许可类型**：开放参考文档

**使用权限**：
- ✅ 可以在其他项目中复用本设计
- ✅ 可以修改和适配到特定场景
- ✅ 可以分享给团队成员学习

**归属说明**：
- 本设计源自债权审查三代理协作系统
- 创建日期：2025-10-26
- 创建者：Claude (Anthropic)

---

## 🔄 文档维护

**版本历史**：

| 版本 | 日期 | 变更说明 |
|-----|------|---------|
| 1.0 | 2025-10-26 | 初始版本，提取并行处理设计 |

**更新计划**：
- 根据新项目的应用经验更新最佳实践
- 补充更多适配案例
- 收集常见问题并更新FAQ

---

## ✅ 快速检查清单

在应用本设计到新项目前，确认以下条件：

```
□ 项目符合多阶段处理模式
□ 每个阶段有明确的输入输出
□ 实体之间相互独立
□ 可以为每个实体创建独立目录
□ 可以生成配置文件
□ 有质量检查的标准
□ 团队理解并行处理的原则
□ 已准备好小规模测试
```

如果所有条件满足，可以开始适配！

---

**文档结束**

如有疑问或需要进一步的适配指导，请参考来源项目的完整实现。
